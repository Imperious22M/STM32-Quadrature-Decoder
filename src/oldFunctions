// Old TPS function!


// Calculates ticks/second at  a rate of SPEED_UPDATE_HZ
// Use direction as discriminant and account for over/underflow
void calcTickPerSec_1()
{
  
  // Overflow time for each channel
  static volatile int overflowTime1 = 0;
  static volatile int overflowTime2 = 0;
  // Direction for shafts
  static int prevDirection1 = quadDecoder.getDirBit();
  static int prevDirection2 = quadDecoder2.getDirBit();
  // Debug vars
  static long prevMillis1 = millis();


  // Increase overflow time
  if(tickDiff1 == 0){
    overflowTime1++;
    // Reset overflow time if an increase no change has been detected 
    // in the set number of overflows
    if(overflowTime1==overflowTimeoutCnt){
      overflowTime1 = 0;
      ticksPerSec1 = 0;
    }
  }
  if(tickDiff2 == 0){
    overflowTime2++;
    if(overflowTime2==overflowTimeoutCnt){
      overflowTime2 = 0;
      ticksPerSec2 = 0;
    }
  }

  // Calculate the ticks/second assuming ticks/speedTimeRate remain constant
  if(tickDiff1==0&&tickDiff2==0){
    // If no tick change, return.
    return;
  }else{
    // Calculate the number of ticks per second
    double timeExtra1 = 0;
    double timeExtra2 = 0;
    // Temporary direction variable to account for overflow
    bool direction = 0;  

    // Calculate the number of time that has passed since the last tick
    if(overflowTime1 > 0){
      timeExtra1 = (float)overflowTime1*speedTimeRate;
      overflowTime1 = 0;
    }
    if(overflowTime2 > 0){
      timeExtra2 = (float)overflowTime2*speedTimeRate;
      overflowTime2 = 0;
    }
    // TODO ADD OVERFLOW TIME

    // Calculate Ticks/Second based on the difference of tick CNT
    if(tickDiff1>0){
      ticksPerSec1 = (tickDiff1) / (speedTimeRate);
      direction = 0;
    } else { 
    // Account for overflow
      ticksPerSec1 = (-1*tickDiff1) / (speedTimeRate);
      direction = 1;
    }

   // If we have overflowed, assume the quadrature counter has also overflowed
   // and correct the count to account for this
    if(ticksPerSec1>UINT16_MAX){
      if(direction == 0 && prevDirection1 == 1){
        // Overflowed from 0 -> 65535
        ticksPerSec1 = (UINT16_MAX + (-1*tickDiff1)) / (speedTimeRate);
      }else{
        ticksPerSec1 = (UINT16_MAX + (tickDiff1)) / (speedTimeRate);
      }
     }
    // Store previous direction for use when the counter overflows
    prevDirection1 = direction;

    direction = 0; // reset direction for second encoder
    // Do the same Ticks Per Second calculation for the second encoder
    if(tickDiff2>0){
      ticksPerSec2 = (tickDiff2) / (speedTimeRate);
      direction = 0;
    } else { 
    // Account for overflow
      ticksPerSec2 = (-1*tickDiff2) / (speedTimeRate);
      direction = 1;
    }
    if(ticksPerSec2>UINT16_MAX){
      if(direction == 0 && prevDirection2 == 1){
        // Overflowed from 0 -> 65535
        ticksPerSec2 = (UINT16_MAX + (-1*tickDiff2)) / (speedTimeRate);
      }else{
        ticksPerSec2 = (UINT16_MAX + (tickDiff2)) / (speedTimeRate);
      }
     }
    // Store previous direction for use when the counter overflows
    prevDirection2 = direction;

    // Error message if overflow remains after it was accounted for
    if(ticksPerSec1>UINT16_MAX || ticksPerSec2>UINT16_MAX){
      if(ticksPerSec1>UINT16_MAX){
        Serial.println("Overflow in TPS1:1000");
      }
      if(ticksPerSec2>UINT16_MAX){
        Serial.println("Overflow in TPS2:2000");
      }
      Serial.println("Overflow error! Ticks per second is too high!");
      Serial.print("Ticks per second: ");
      Serial.println(ticksPerSec1);  
      Serial.print("tick diff: ");
      Serial.println(tickDiff1);
      Serial.print("Previous tick count: ");
      Serial.println(prevTickCnt1);
      Serial.print("Direction: ");
      Serial.println(direction);
      Serial.println("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
      Serial.println();
      return;
    }

    
    if(ticksPerSec1>=200){
      Serial.println("200 error!!");
      Serial.print("Ticks per second: ");
      Serial.println(ticksPerSec1);  
      Serial.print("tick diff: ");
      Serial.println(tickDiff1);
      Serial.print("Previous tick count: ");
      Serial.println(prevTickCnt1);
      Serial.print("Direction: ");
      Serial.println(direction);
      Serial.print("Overflow Time:");
      Serial.println(overflowTime1);
      Serial.print("Millis Diff: ");
      Serial.println(millis()-prevMillis1);
      Serial.println("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
      Serial.println();
    }

    prevMillis1 = millis();
  }
}